From eff6a4a7effff53fbf7b5b8ea5edbc8ca2d70f08 Mon Sep 17 00:00:00 2001
From: paradadf <paradadf@users.noreply.github.com>
Date: Mon, 8 Jul 2019 22:39:18 -0400
Subject: [PATCH 1/2] fix SELECT as hotkey sometimes messy with arcade

This fixes the hotkey being sometimes messy with arcade when on SELECT.
---
 retroarch.c | 27 +++++++++++++++++++++++----
 1 file changed, 23 insertions(+), 4 deletions(-)

diff --git a/retroarch.c b/retroarch.c
index 48675eed6d..50c9db40e9 100644
--- a/retroarch.c
+++ b/retroarch.c
@@ -1821,6 +1821,10 @@ struct rarch_state
    bool input_driver_block_libretro_input;
    bool input_driver_nonblock_state;

+/* number of frames required to trigger the hotkey */
+#define HOTKEY_DELAY 5
+   unsigned hotkey_counter;
+
 #ifdef HAVE_MENU
    bool menu_input_dialog_keyboard_display;
    /* Is the menu driver still running? */
@@ -17199,11 +17224,17 @@ static void input_menu_keys_pressed(input_bits_t *p_new_state,
                && p_rarch->current_input->input_state(p_rarch->current_input_data, joypad_info,
                   &binds[0], port, RETRO_DEVICE_JOYPAD, 0, RARCH_ENABLE_HOTKEY))
          {
-            p_rarch->input_driver_block_libretro_input = true;
-            break;
+            if (p_rarch->hotkey_counter < HOTKEY_DELAY)
+               p_rarch->hotkey_counter++;
+            if (p_rarch->hotkey_counter >= HOTKEY_DELAY)
+            {
+               p_rarch->input_driver_block_libretro_input = true;
+               break;
+            }
          }
          else
          {
+            p_rarch->hotkey_counter = 0;
             p_rarch->input_driver_block_hotkey         = true;
             break;
          }
@@ -17320,9 +17351,18 @@ static void input_keys_pressed(input_bits_t *p_new_state,
                p_rarch->current_input_data, joypad_info,
                &binds, port,
                RETRO_DEVICE_JOYPAD, 0, RARCH_ENABLE_HOTKEY))
-         p_rarch->input_driver_block_libretro_input = true;
-      else
+      {
+         if (p_rarch->hotkey_counter < HOTKEY_DELAY)
+            p_rarch->hotkey_counter++;
+         if (p_rarch->hotkey_counter >= HOTKEY_DELAY)
+         {
+             p_rarch->input_driver_block_libretro_input = true;
+         }
+      }
+      else {
+         p_rarch->hotkey_counter = 0;
          p_rarch->input_driver_block_hotkey         = true;
+      }
    }

    if (binds[RARCH_GAME_FOCUS_TOGGLE].valid)

